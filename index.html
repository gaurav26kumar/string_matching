<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Algorithm Visualizer Pro</title>
    <link rel="shortcut icon" href="./assets/favicon.png" type="image/x-icon">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        
        :root {
            /* Professional color scheme */
            --bg-primary: #f8fafc;
            --bg-secondary: #f1f5f9;
            --bg-tertiary: #e2e8f0;
            --bg-glass: rgba(255, 255, 255, 0.7);
            --bg-glass-hover: rgba(255, 255, 255, 0.9);
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-tertiary: #64748b;
            --accent-primary: #3b82f6;
            --accent-secondary: #6366f1;
            --accent-tertiary: #8b5cf6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-error: #ef4444;
            --gradient-primary: linear-gradient(135deg, #3b82f6 0%, #6366f1 100%);
            --gradient-secondary: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            --gradient-tertiary: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%);
            --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-glass: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.7) 100%);
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.3);
            --shadow-glow-purple: 0 0 20px rgba(99, 102, 241, 0.3);
            --shadow-glow-pink: 0 0 20px rgba(139, 92, 246, 0.3);
            --border-radius: 6px;
            --border-radius-lg: 8px;
            --border-radius-xl: 10px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-glass: rgba(30, 41, 59, 0.7);
            --bg-glass-hover: rgba(30, 41, 59, 0.9);
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.4;
            overflow: hidden;
            transition: var(--transition);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header - Compact */
        header {
            position: relative;
            z-index: 100;
            padding: 0.75rem 0;
            background: var(--bg-glass);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            flex-shrink: 0;
        }

        .header-content {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo {
            width: 36px;
            height: 36px;
            background: var(--gradient-primary);
            border-radius: var(--border-radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.2rem;
            color: white;
            box-shadow: var(--shadow-md);
        }

        .logo-text {
            display: flex;
            flex-direction: column;
        }

        .logo-title {
            font-size: 1.25rem;
            font-weight: 800;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }

        .logo-subtitle {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .theme-toggle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-glass);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            font-size: 1rem;
        }

        .theme-toggle:hover {
            background: var(--bg-glass-hover);
            transform: scale(1.05);
        }

        /* Main Container - Grid Layout */
        .main-container {
            flex: 1;
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 1fr auto;
            gap: 0.75rem;
            padding: 0.75rem;
            max-height: calc(100vh - 60px);
            overflow: hidden;
        }

        /* Left Panel - Algorithm Selection & Controls */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow-y: auto;
        }

        .input-section {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: var(--border-radius-xl);
            padding: 1rem;
            position: relative;
            overflow: hidden;
        }

        .input-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--gradient-primary);
        }

        .input-group {
            margin-bottom: 0.75rem;
        }

        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .input-wrapper {
            position: relative;
            display: flex;
            gap: 0.25rem;
        }

        .input-field {
            flex: 1;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            font-size: 0.875rem;
            color: var(--text-primary);
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .generate-btn {
            padding: 0.5rem 0.75rem;
            background: var(--gradient-tertiary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }

        .generate-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .algorithm-selector {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .algo-card {
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .algo-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-primary);
            opacity: 0;
            transition: var(--transition);
        }

        .algo-card.active {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .algo-card.active::before {
            opacity: 0.1;
        }

        .algo-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
            position: relative;
            z-index: 1;
        }

        .algo-icon {
            width: 32px;
            height: 32px;
            background: var(--gradient-primary);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 0.875rem;
        }

        .algo-name {
            font-weight: 700;
            font-size: 0.875rem;
        }

        .algo-description {
            color: var(--text-secondary);
            font-size: 0.75rem;
            position: relative;
            z-index: 1;
        }

        .control-section {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: var(--border-radius-xl);
            padding: 1rem;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .btn-danger {
            background: var(--gradient-secondary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-danger:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px solid rgba(148, 163, 184, 0.2);
        }

        .btn-secondary:hover {
            background: var(--bg-glass-hover);
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
        }

        .speed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .speed-slider {
            width: 100px;
            height: 4px;
            border-radius: 2px;
            background: rgba(148, 163, 184, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            transition: var(--transition);
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: var(--shadow-glow);
        }

        .speed-value {
            font-size: 0.75rem;
            color: var(--accent-primary);
            font-weight: 600;
            min-width: 40px;
        }

        /* Middle Panel - Visualization */
        .middle-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow: hidden;
        }

        .visualization-section {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: var(--border-radius-xl);
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 800;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .visualization-canvas {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 0.75rem;
            min-height: 120px;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            flex: 1;
        }

        .string-row {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 2;
        }

        .pattern-row {
            transition: transform 0.3s ease;
        }

        .char-cell {
            width: 32px;
            height: 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            border: 2px solid rgba(148, 163, 184, 0.2);
            border-radius: var(--border-radius);
            font-weight: 700;
            font-size: 0.875rem;
            font-family: 'JetBrains Mono', monospace;
            position: relative;
            transition: var(--transition);
        }

        .char-index {
            position: absolute;
            top: -6px;
            font-size: 0.5rem;
            color: var(--text-tertiary);
            font-weight: 500;
        }

        .char-cell.comparing {
            animation: comparePulse 1s infinite;
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }

        @keyframes comparePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .char-cell.match {
            background: var(--gradient-success);
            color: white;
            transform: scale(1.1);
            animation: matchBounce 0.5s ease-out;
        }

        @keyframes matchBounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1.1); }
        }

        .char-cell.mismatch {
            background: var(--gradient-secondary);
            color: white;
            animation: mismatchShake 0.5s ease-out;
        }

        @keyframes mismatchShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .window-overlay {
            position: absolute;
            top: 0;
            height: 100%;
            border: 3px solid var(--accent-primary);
            border-radius: var(--border-radius);
            background: rgba(59, 130, 246, 0.05);
            pointer-events: none;
            transition: var(--transition);
            box-shadow: var(--shadow-glow);
            z-index: 1;
        }

        .status-bar {
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .status-icon {
            font-size: 1rem;
        }

        .status-text {
            flex: 1;
            font-weight: 500;
        }

        .status-bar.success {
            border-left-color: var(--accent-success);
        }

        .status-bar.error {
            border-left-color: var(--accent-error);
        }

        .status-bar.info {
            border-left-color: var(--accent-primary);
        }

        /* LPS Table Section */
        .lps-table-section {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: var(--border-radius-xl);
            padding: 1rem;
            max-height: 200px;
            overflow: auto;
        }

        .table-wrapper {
            overflow-x: auto;
        }

        .algo-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 0.75rem;
        }

        .algo-table th {
            background: var(--gradient-primary);
            color: white;
            padding: 0.5rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .algo-table th:first-child {
            border-top-left-radius: var(--border-radius);
        }

        .algo-table th:last-child {
            border-top-right-radius: var(--border-radius);
        }

        .algo-table td {
            padding: 0.5rem;
            text-align: center;
            background: var(--bg-tertiary);
            border-top: 1px solid rgba(148, 163, 184, 0.1);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }

        /* Right Panel - Algorithm Explorer */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow: hidden;
        }

        .pseudocode-section {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: var(--border-radius-xl);
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .pseudocode-container {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .pseudocode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .pseudocode-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .pseudocode-toggle {
            display: flex;
            gap: 0.25rem;
        }

        .toggle-btn {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 4px;
            font-size: 0.625rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
        }

        .toggle-btn.active {
            background: var(--accent-primary);
            color: white;
        }

        .pseudocode-live {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.25rem;
            position: relative;
        }

        .pseudocode-live::-webkit-scrollbar {
            width: 4px;
        }

        .pseudocode-live::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 2px;
        }

        .pseudocode-live::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 2px;
        }

        .pseudocode-line {
            padding: 0.25rem 0.5rem;
            margin: 0.125rem 0;
            border-radius: 4px;
            transition: var(--transition);
            position: relative;
        }

        .pseudocode-line.active {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid var(--accent-primary);
            font-weight: 600;
        }

        .pseudocode-line.executed {
            opacity: 0.6;
        }

        .pseudocode-keyword {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .pseudocode-comment {
            color: var(--text-tertiary);
            font-style: italic;
        }

        .pseudocode-function {
            color: var(--accent-secondary);
            font-weight: 600;
        }

        .pseudocode-variable {
            color: var(--accent-tertiary);
        }

        .pseudocode-string {
            color: var(--accent-success);
        }

        .algorithm-story {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
            font-size: 0.75rem;
            line-height: 1.4;
            color: var(--text-secondary);
            position: relative;
        }

        .algorithm-story::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--gradient-tertiary);
        }

        .story-content {
            padding-left: 0.75rem;
            height: 100%;
            overflow-y: auto;
            padding-right: 0.25rem;
        }

        .story-content::-webkit-scrollbar {
            width: 4px;
        }

        .story-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 2px;
        }

        .story-content::-webkit-scrollbar-thumb {
            background: var(--accent-tertiary);
            border-radius: 2px;
        }

        .story-paragraph {
            margin-bottom: 0.5rem;
        }

        .story-highlight {
            color: var(--accent-tertiary);
            font-weight: 600;
        }

        .step-explanation {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--accent-primary);
            animation: slideIn 0.3s ease-out;
            font-size: 0.75rem;
        }

        @keyframes slideIn {
            from { transform: translateY(-10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .step-explanation-title {
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .step-explanation-content {
            color: var(--text-secondary);
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .execution-history {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-radius: var(--border-radius);
            font-size: 0.75rem;
            max-height: 150px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .execution-header {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .execution-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.25rem;
        }

        .execution-list::-webkit-scrollbar {
            width: 4px;
        }

        .execution-list::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 2px;
        }

        .execution-list::-webkit-scrollbar-thumb {
            background: var(--accent-tertiary);
            border-radius: 2px;
        }

        .execution-step {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            border-left: 3px solid transparent;
            transition: var(--transition);
            animation: stepAppear 0.3s ease-out;
        }

        @keyframes stepAppear {
            from { 
                opacity: 0; 
                transform: translateX(-20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        .execution-step.active {
            border-left-color: var(--accent-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .execution-step.match {
            border-left-color: var(--accent-success);
            background: rgba(16, 185, 129, 0.05);
        }

        .execution-step.mismatch {
            border-left-color: var(--accent-error);
            background: rgba(239, 68, 68, 0.05);
        }

        .execution-step.found {
            border-left-color: var(--accent-tertiary);
            background: rgba(139, 92, 246, 0.05);
        }

        .step-number {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.625rem;
            color: var(--text-secondary);
        }

        .execution-step.active .step-number {
            background: var(--accent-primary);
            color: white;
        }

        .execution-step.match .step-number {
            background: var(--accent-success);
            color: white;
        }

        .execution-step.mismatch .step-number {
            background: var(--accent-error);
            color: white;
        }

        .execution-step.found .step-number {
            background: var(--accent-tertiary);
            color: white;
        }

        .step-details {
            flex: 1;
        }

        .step-action {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.125rem;
            font-size: 0.75rem;
        }

        .step-description {
            color: var(--text-secondary);
            font-size: 0.6875rem;
            line-height: 1.3;
        }

        .step-variables {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.125rem;
            flex-wrap: wrap;
        }

        .step-variable {
            padding: 0.125rem 0.25rem;
            background: var(--bg-tertiary);
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.5625rem;
            color: var(--text-tertiary);
        }

        /* Background - Simplified */
        .bg-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .bg-gradient {
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background: radial-gradient(circle at 20% 80%, rgba(59, 130, 246, 0.05) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(99, 102, 241, 0.05) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(139, 92, 246, 0.03) 0%, transparent 50%);
        }

        .bg-grid {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(148, 163, 184, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(148, 163, 184, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 250px 1fr 280px;
            }
        }

        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
            }
            
            .left-panel, .right-panel {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 0.75rem;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
            }
            
            .left-panel, .right-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="bg-container">
        <div class="bg-gradient"></div>
        <div class="bg-grid"></div>
    </div>

    <header>
        <div class="header-content">
            <div class="logo-section">
                <div class="logo">SA</div>
                <div class="logo-text">
                    <div class="logo-title">String Algorithm Visualizer</div>
                    <div class="logo-subtitle">Advanced Pattern Matching Analysis</div>
                </div>
            </div>
            <div class="header-actions">
                <button class="theme-toggle" id="themeToggle">
                    <span id="themeIcon">üåô</span>
                </button>
            </div>
        </div>
    </header>

    <div class="main-container">
        <!-- Left Panel: Algorithm Selection & Controls -->
        <div class="left-panel">
            <div class="input-section">
                <div class="input-group">
                    <label class="input-label" for="textInput">Text String</label>
                    <div class="input-wrapper">
                        <input type="text" id="textInput" class="input-field" placeholder="Enter text..." value="ABABDABACDABABCABAB">
                        <button class="generate-btn" id="generateTextBtn">
                            <span>üé≤</span>
                        </button>
                    </div>
                </div>
                <div class="input-group">
                    <label class="input-label" for="patternInput">Pattern String</label>
                    <div class="input-wrapper">
                        <input type="text" id="patternInput" class="input-field" placeholder="Enter pattern..." value="ABABCABAB">
                        <button class="generate-btn" id="generatePatternBtn">
                            <span>üé≤</span>
                        </button>
                    </div>
                </div>
                <div class="algorithm-selector">
                    <div class="algo-card active" id="kmpCard">
                        <div class="algo-header">
                            <div class="algo-icon">KMP</div>
                            <div class="algo-name">Knuth-Morris-Pratt</div>
                        </div>
                        <div class="algo-description">Efficient pattern matching using LPS array</div>
                    </div>
                    <div class="algo-card" id="bmCard">
                        <div class="algo-header">
                            <div class="algo-icon">BM</div>
                            <div class="algo-name">Boyer-Moore</div>
                        </div>
                        <div class="algo-description">Fast matching using bad character heuristic</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <div class="control-panel">
                    <button class="btn btn-primary" id="startBtn">
                        <span>‚ñ∂</span>
                        <span>Start</span>
                    </button>
                    <button class="btn btn-danger" id="haltBtn" disabled>
                        <span>‚è∏</span>
                        <span>Halt</span>
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        <span>‚Ü∫</span>
                        <span>Reset</span>
                    </button>
                    <div class="speed-control">
                        <span class="speed-label">Speed</span>
                        <input type="range" id="speedSlider" class="speed-slider" min="100" max="2000" value="1000">
                        <span class="speed-value" id="speedValue">1000ms</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Middle Panel: Visualization -->
        <div class="middle-panel">
            <div class="visualization-section">
                <div class="section-header">
                    <h2 class="section-title">Live Visualization</h2>
                </div>
                <div class="visualization-canvas">
                    <div class="string-row" id="textRow"></div>
                    <div class="string-row pattern-row" id="patternRow"></div>
                    <div class="window-overlay" id="windowOverlay"></div>
                </div>
                <div id="statusBar"></div>
            </div>
            
            <div class="lps-table-section">
                <div class="section-header">
                    <h3 class="section-title">Algorithm Table</h3>
                </div>
                <div class="table-wrapper" id="tableWrapper"></div>
            </div>
        </div>

        <!-- Right Panel: Algorithm Explorer -->
        <div class="right-panel">
            <div class="pseudocode-section">
                <div class="pseudocode-container">
                    <div class="pseudocode-header">
                        <div class="pseudocode-title">Algorithm Explorer</div>
                        <div class="pseudocode-toggle">
                            <button class="toggle-btn active" id="codeToggle">Code</button>
                            <button class="toggle-btn" id="storyToggle">Story</button>
                        </div>
                    </div>
                    <div class="pseudocode-live" id="pseudocodeLive"></div>
                    <div class="algorithm-story" id="algorithmStory">
                        <div class="story-content" id="storyContent">
                            <p class="story-paragraph">Welcome to the <span class="story-highlight">String Algorithm Visualizer</span>! Let's explore how pattern matching works step by step.</p>
                            <p class="story-paragraph">Click "Start" to begin the visualization and watch as the algorithm searches for your pattern in the text.</p>
                        </div>
                    </div>
                </div>
                
                <div class="step-explanation" id="stepExplanation" style="display: none;">
                    <div class="step-explanation-title">
                        <span>üí°</span>
                        <span>What's Happening</span>
                    </div>
                    <div class="step-explanation-content" id="stepExplanationContent">
                        The algorithm is preparing to search for the pattern in the text.
                    </div>
                </div>
            </div>
            
            <div class="execution-history">
                <div class="execution-header">
                    <span>üìú</span>
                    <span>Execution History</span>
                </div>
                <div class="execution-list" id="executionList">
                    <div class="execution-step">
                        <div class="step-number">0</div>
                        <div class="step-details">
                            <div class="step-action">Ready to Start</div>
                            <div class="step-description">Click "Start" to begin the algorithm visualization</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Theme Management
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const htmlElement = document.documentElement;

        themeToggle.addEventListener('click', () => {
            const currentTheme = htmlElement.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                htmlElement.removeAttribute('data-theme');
                themeIcon.textContent = 'üåô';
                localStorage.setItem('theme', 'light');
            } else {
                htmlElement.setAttribute('data-theme', 'dark');
                themeIcon.textContent = '‚òÄÔ∏è';
                localStorage.setItem('theme', 'dark');
            }
        });

        // Load saved theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            htmlElement.setAttribute('data-theme', 'dark');
            themeIcon.textContent = '‚òÄÔ∏è';
        }

        // Pseudocode/Story Toggle
        const codeToggle = document.getElementById('codeToggle');
        const storyToggle = document.getElementById('storyToggle');
        const pseudocodeLive = document.getElementById('pseudocodeLive');
        const algorithmStory = document.getElementById('algorithmStory');

        codeToggle.addEventListener('click', () => {
            codeToggle.classList.add('active');
            storyToggle.classList.remove('active');
            pseudocodeLive.style.display = 'block';
            algorithmStory.style.display = 'none';
        });

        storyToggle.addEventListener('click', () => {
            storyToggle.classList.add('active');
            codeToggle.classList.remove('active');
            pseudocodeLive.style.display = 'none';
            algorithmStory.style.display = 'block';
        });

        // Algorithm Selection
        const kmpCard = document.getElementById('kmpCard');
        const bmCard = document.getElementById('bmCard');
        let currentAlgorithm = 'kmp';

        kmpCard.addEventListener('click', () => {
            currentAlgorithm = 'kmp';
            kmpCard.classList.add('active');
            bmCard.classList.remove('active');
            resetVisualization();
        });

        bmCard.addEventListener('click', () => {
            currentAlgorithm = 'boyer-moore';
            bmCard.classList.add('active');
            kmpCard.classList.remove('active');
            resetVisualization();
        });

        // Random String Generator
        const generateTextBtn = document.getElementById('generateTextBtn');
        const generatePatternBtn = document.getElementById('generatePatternBtn');

        const testCases = [
            {
                text: "ABABDABACDABABCABAB",
                pattern: "ABABCABAB",
                description: "Classic KMP example with overlapping patterns"
            },
            {
                text: "ABCABCDABABCDABCDABCD",
                pattern: "ABCDABCD",
                description: "Repeating pattern with prefix-suffix properties"
            },
            {
                text: "AABAACAABAAABAAABAACAA",
                pattern: "AABAACAABAA",
                description: "Complex pattern with multiple matches"
            },
            {
                text: "ABCDABCEABCDABCFABCDABCG",
                pattern: "ABCDABCDA",
                description: "Pattern with internal repetition"
            },
            {
                text: "AAAAAAABAAAAAAABAAAAAAAB",
                pattern: "AAAAAAAB",
                description: "Long pattern with many As"
            },
            {
                text: "ABCDABCEABCDABCFABCDABCE",
                pattern: "ABCDABCE",
                description: "Pattern appears multiple times"
            },
            {
                text: "BABABABABABABABABABABAB",
                pattern: "BABABAB",
                description: "Simple alternating pattern"
            },
            {
                text: "AAAABAAAABAAAABAAAABAAA",
                pattern: "AAAAB",
                description: "Pattern with many As and Bs"
            },
            {
                text: "ABCDABEFABCDABGHABCDABIJ",
                pattern: "ABCDAB",
                description: "Pattern with variations"
            }
        ];

        const patternTemplates = [
            "ABAB", "ABC", "ABCD", "AAB", "ABA", "ABCAB", "ABABC", 
            "ABCABC", "AABAAB", "ABABAB", "ABCABCAB", "ABABCABAB",
            "AABAACAABAA", "ABCDABCD", "ABCABCDAB", "ABCDABCDA",
            "AAAAAAAB", "BABABAB", "AAAAB", "ABCDABCE", "ABCDAB"
        ];

        function generateRandomString(length, alphabet = 'ABCD') {
            let result = '';
            for (let i = 0; i < length; i++) {
                result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
            }
            return result;
        }

        function generateMatchingText(pattern) {
            const textLength = Math.floor(Math.random() * 15) + 20;
            const numMatches = Math.floor(Math.random() * 2) + 1;
            
            let text = '';
            
            const prefixLength = Math.floor(Math.random() * 5) + 2;
            text += generateRandomString(prefixLength);
            
            text += pattern;
            
            if (numMatches === 2 || textLength - text.length > pattern.length + 5) {
                const middleLength = Math.min(Math.floor(Math.random() * 8) + 3, textLength - text.length - pattern.length - 2);
                text += generateRandomString(middleLength);
                
                if (text.length + pattern.length <= textLength) {
                    text += pattern;
                }
            }
            
            while (text.length < textLength) {
                text += generateRandomString(1);
            }
            
            return text;
        }

        function generateRandomPattern() {
            if (Math.random() < 0.7) {
                return patternTemplates[Math.floor(Math.random() * patternTemplates.length)];
            } else {
                const length = Math.floor(Math.random() * 4) + 3;
                return generateRandomString(length, 'ABCD');
            }
        }

        function generateRandomText() {
            if (Math.random() < 0.6) {
                const testCase = testCases[Math.floor(Math.random() * testCases.length)];
                return testCase.text;
            } else {
                const length = Math.floor(Math.random() * 10) + 20;
                return generateRandomString(length, 'ABCD');
            }
        }

        generateTextBtn.addEventListener('click', () => {
            const currentPattern = patternInput.value.trim();
            let newText;
            
            if (currentPattern && Math.random() < 0.8) {
                newText = generateMatchingText(currentPattern);
            } else {
                newText = generateRandomText();
            }
            
            textInput.value = newText;
            resetVisualization();
            showStatus('üé≤ Generated random text string', 'info');
        });

        generatePatternBtn.addEventListener('click', () => {
            const newPattern = generateRandomPattern();
            patternInput.value = newPattern;
            
            if (Math.random() < 0.5) {
                const matchingText = generateMatchingText(newPattern);
                textInput.value = matchingText;
                showStatus('üé≤ Generated matching pattern and text', 'info');
            } else {
                showStatus('üé≤ Generated random pattern string', 'info');
            }
            
            resetVisualization();
        });

        // Input Elements
        const textInput = document.getElementById('textInput');
        const patternInput = document.getElementById('patternInput');
        const startBtn = document.getElementById('startBtn');
        const haltBtn = document.getElementById('haltBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        // Display Elements
        const textRow = document.getElementById('textRow');
        const patternRow = document.getElementById('patternRow');
        const windowOverlay = document.getElementById('windowOverlay');
        const tableWrapper = document.getElementById('tableWrapper');
        const statusBar = document.getElementById('statusBar');
        const stepExplanation = document.getElementById('stepExplanation');
        const stepExplanationContent = document.getElementById('stepExplanationContent');
        const storyContent = document.getElementById('storyContent');
        const executionList = document.getElementById('executionList');

        // Speed Control
        speedSlider.addEventListener('input', () => {
            speedValue.textContent = `${speedSlider.value}ms`;
        });

        // Visualization State
        let text = '';
        let pattern = '';
        let isRunning = false;
        let isPaused = false;
        let animationSpeed = 1000;
        let currentStep = 0;
        let matches = [];
        let comparisons = 0;
        let animationTimeout;
        let naiveComparisons = 0;
        let executionSteps = [];

        // Pseudocode templates
        const kmpPseudocode = [
            { 
                type: 'function', 
                text: '<span class="pseudocode-keyword">function</span> <span class="pseudocode-function">KMPSearch</span>(text, pattern):',
                explanation: "Starting the KMP algorithm to find the pattern in the text."
            },
            { 
                type: 'variable', 
                text: '    n = length of text',
                explanation: "Getting the length of the text."
            },
            { 
                type: 'variable', 
                text: '    m = length of pattern',
                explanation: "Getting the length of the pattern."
            },
            { 
                type: 'variable', 
                text: '    lps = computeLPSArray(pattern)',
                explanation: "Creating the LPS (Longest Prefix Suffix) table."
            },
            { 
                type: 'variable', 
                text: '    i = 0  <span class="pseudocode-comment">// index for text</span>',
                explanation: "Starting from the beginning of the text."
            },
            { 
                type: 'variable', 
                text: '    j = 0  <span class="pseudocode-comment">// index for pattern</span>',
                explanation: "Starting from the beginning of the pattern."
            },
            { 
                type: 'loop', 
                text: '    <span class="pseudocode-keyword">while</span> i < n:',
                explanation: "Searching until we've checked all characters in the text."
            },
            { 
                type: 'condition', 
                text: '        <span class="pseudocode-keyword">if</span> pattern[j] == text[i]:',
                explanation: "Checking if the current characters match."
            },
            { 
                type: 'action', 
                text: '            i = i + 1',
                explanation: "Moving to the next character in the text."
            },
            { 
                type: 'action', 
                text: '            j = j + 1',
                explanation: "Moving to the next character in the pattern."
            },
            { 
                type: 'condition', 
                text: '            <span class="pseudocode-keyword">if</span> j == m:',
                explanation: "Checking if we've matched all characters in the pattern."
            },
            { 
                type: 'action', 
                text: '                print(<span class="pseudocode-string">"Pattern found at index "</span> + (i-j))',
                explanation: "Recording where we found the match."
            },
            { 
                type: 'action', 
                text: '                j = lps[j-1]',
                explanation: "Using the LPS table to continue searching efficiently."
            },
            { 
                type: 'condition', 
                text: '        <span class="pseudocode-keyword">else</span>:',
                explanation: "If the characters don't match..."
            },
            { 
                type: 'condition', 
                text: '            <span class="pseudocode-keyword">if</span> j != 0:',
                explanation: "If we're not at the beginning of the pattern..."
            },
            { 
                type: 'action', 
                text: '                j = lps[j-1]',
                explanation: "Using the LPS table to jump to the best position."
            },
            { 
                type: 'condition', 
                text: '            <span class="pseudocode-keyword">else</span>:',
                explanation: "If we're at the beginning of the pattern..."
            },
            { 
                type: 'action', 
                text: '                i = i + 1',
                explanation: "Moving to the next character in the text."
            }
        ];

        const bmPseudocode = [
            { 
                type: 'function', 
                text: '<span class="pseudocode-keyword">function</span> <span class="pseudocode-function">boyerMooreSearch</span>(text, pattern):',
                explanation: "Starting the Boyer-Moore algorithm, which compares from right to left!"
            },
            { 
                type: 'variable', 
                text: '    n = length of text',
                explanation: "Getting the length of the text."
            },
            { 
                type: 'variable', 
                text: '    m = length of pattern',
                explanation: "Getting the length of the pattern."
            },
            { 
                type: 'variable', 
                text: '    badChar = computeBadCharTable(pattern)',
                explanation: "Creating the bad character table."
            },
            { 
                type: 'variable', 
                text: '    shift = 0',
                explanation: "Initializing the shift position."
            },
            { 
                type: 'loop', 
                text: '    <span class="pseudocode-keyword">while</span> shift <= (n - m):',
                explanation: "Searching until we've checked all possible positions."
            },
            { 
                type: 'variable', 
                text: '        j = m - 1',
                explanation: "Starting from the END of the pattern!"
            },
            { 
                type: 'loop', 
                text: '        <span class="pseudocode-keyword">while</span> j >= 0 and pattern[j] == text[shift + j]:',
                explanation: "Comparing characters from right to left."
            },
            { 
                type: 'action', 
                text: '            j = j - 1',
                explanation: "Moving one position to the left."
            },
            { 
                type: 'condition', 
                text: '        <span class="pseudocode-keyword">if</span> j < 0:',
                explanation: "If all characters matched..."
            },
            { 
                type: 'action', 
                text: '            print(<span class="pseudocode-string">"Pattern found at index "</span> + shift)',
                explanation: "Recording where we found the match."
            },
            { 
                type: 'condition', 
                text: '            <span class="pseudocode-keyword">if</span> shift + m < n:',
                explanation: "If there's still text left after our pattern..."
            },
            { 
                type: 'action', 
                text: '                shift = shift + m - badChar[ASCII(text[shift + m])]',
                explanation: "Making a big jump forward in the text!"
            },
            { 
                type: 'condition', 
                text: '            <span class="pseudocode-keyword">else</span>:',
                explanation: "If we're at the end of the text..."
            },
            { 
                type: 'action', 
                text: '                shift = shift + 1',
                explanation: "Moving one position forward."
            },
            { 
                type: 'condition', 
                text: '        <span class="pseudocode-keyword">else</span>:',
                explanation: "If we found a mismatch..."
            },
            { 
                type: 'action', 
                text: '            shift = shift + max(1, j - badChar[ASCII(text[shift + j])])',
                explanation: "Making a smart jump based on the bad character rule."
            }
        ];

        // Initialize pseudocode display
        function initializePseudocode() {
            const pseudocode = currentAlgorithm === 'kmp' ? kmpPseudocode : bmPseudocode;
            pseudocodeLive.innerHTML = '';
            
            pseudocode.forEach((line, index) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'pseudocode-line';
                lineDiv.id = `pseudo-line-${index}`;
                lineDiv.innerHTML = line.text;
                pseudocodeLive.appendChild(lineDiv);
            });
            
            updateStoryContent();
        }

        // Update pseudocode highlighting
        function updatePseudocodeHighlight(lineIndex) {
            document.querySelectorAll('.pseudocode-line').forEach((line, index) => {
                if (index < lineIndex) {
                    line.classList.add('executed');
                    line.classList.remove('active');
                } else if (index === lineIndex) {
                    line.classList.add('active');
                    line.classList.remove('executed');
                } else {
                    line.classList.remove('active', 'executed');
                }
            });
            
            const pseudocode = currentAlgorithm === 'kmp' ? kmpPseudocode : bmPseudocode;
            if (lineIndex >= 0 && lineIndex < pseudocode.length) {
                stepExplanation.style.display = 'block';
                stepExplanationContent.textContent = pseudocode[lineIndex].explanation;
            }
        }

        // Update story content
        function updateStoryContent() {
            if (currentAlgorithm === 'kmp') {
                storyContent.innerHTML = `
                    <p class="story-paragraph">Welcome to the <span class="story-highlight">KMP Algorithm</span> adventure! This algorithm is like a smart reader who remembers where they've seen parts of the word before.</p>
                    <p class="story-paragraph">It creates a special map called the <span class="story-highlight">LPS table</span> that helps it jump ahead instead of starting over.</p>
                    <p class="story-paragraph">Watch as the algorithm compares characters, and when it finds a mismatch, it uses its LPS table to know exactly where to continue from!</p>
                `;
            } else {
                storyContent.innerHTML = `
                    <p class="story-paragraph">Welcome to the <span class="story-highlight">Boyer-Moore Algorithm</span> adventure! This algorithm works backwards to solve a mystery faster.</p>
                    <p class="story-paragraph">Instead of starting from the beginning, Boyer-Moore compares characters from the END of the pattern.</p>
                    <p class="story-paragraph">When it finds a mismatch, it uses a clever trick called the <span class="story-highlight">bad character rule</span> to jump ahead in the text!</p>
                `;
            }
        }

        // Add execution step to history
        function addExecutionStep(stepNumber, action, description, variables = [], type = 'normal') {
            const stepDiv = document.createElement('div');
            stepDiv.className = `execution-step ${type}`;
            stepDiv.innerHTML = `
                <div class="step-number">${stepNumber}</div>
                <div class="step-details">
                    <div class="step-action">${action}</div>
                    <div class="step-description">${description}</div>
                    ${variables.length > 0 ? `
                        <div class="step-variables">
                            ${variables.map(v => `<span class="step-variable">${v}</span>`).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
            
            executionList.appendChild(stepDiv);
            executionList.scrollTop = executionList.scrollHeight;
            
            document.querySelectorAll('.execution-step').forEach((step, index) => {
                step.classList.remove('active');
                if (index === stepNumber) {
                    step.classList.add('active');
                }
            });
        }

        // KMP Algorithm Implementation
        function computeLPSArray() {
            const lps = new Array(pattern.length).fill(0);
            let len = 0;
            let i = 1;
            
            while (i < pattern.length) {
                if (pattern[i] === pattern[len]) {
                    len++;
                    lps[i] = len;
                    i++;
                } else {
                    if (len !== 0) {
                        len = lps[len - 1];
                    } else {
                        lps[i] = 0;
                        i++;
                    }
                }
            }
            
            return lps;
        }

        function displayLPSTable(lps) {
            let tableHTML = `
                <table class="algo-table">
                    <thead>
                        <tr>
                            <th>Index</th>
            `;
            
            for (let i = 0; i < pattern.length; i++) {
                tableHTML += `<th>${i}</th>`;
            }
            
            tableHTML += `
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Pattern</strong></td>
            `;
            
            for (let i = 0; i < pattern.length; i++) {
                tableHTML += `<td>${pattern[i]}</td>`;
            }
            
            tableHTML += `
                        </tr>
                        <tr>
                            <td><strong>LPS</strong></td>
            `;
            
            for (let i = 0; i < lps.length; i++) {
                tableHTML += `<td>${lps[i]}</td>`;
            }
            
            tableHTML += `
                        </tr>
                    </tbody>
                </table>
            `;
            
            tableWrapper.innerHTML = tableHTML;
        }

        function KMPSearch() {
            const lps = computeLPSArray();
            displayLPSTable(lps);
            
            let i = 0; // index for text
            let j = 0; // index for pattern
            matches = [];
            comparisons = 0;
            
            naiveComparisons = text.length * pattern.length;
            
            const steps = [];
            
            steps.push({
                textIndex: -1,
                patternIndex: -1,
                patternPosition: 0,
                i: i,
                j: j,
                matches: [...matches],
                comparisons: comparisons,
                pseudoLine: 0,
                explanation: "Starting the KMP algorithm to find the pattern in the text."
            });
            
            while (i < text.length) {
                comparisons++;
                
                steps.push({
                    textIndex: i,
                    patternIndex: j,
                    patternPosition: i - j,
                    matched: j === pattern.length - 1 && text[i] === pattern[j],
                    isMatch: text[i] === pattern[j],
                    i: i,
                    j: j,
                    matches: [...matches],
                    comparisons: comparisons,
                    pseudoLine: 7,
                    explanation: `Comparing text[${i}]='${text[i]}' with pattern[${j}]='${pattern[j]}'`
                });
                
                if (pattern[j] === text[i]) {
                    i++;
                    j++;
                    
                    steps.push({
                        textIndex: i - 1,
                        patternIndex: j - 1,
                        patternPosition: i - j,
                        isMatch: true,
                        i: i,
                        j: j,
                        matches: [...matches],
                        comparisons: comparisons,
                        pseudoLine: 8,
                        explanation: "Characters match! Moving to the next characters in both text and pattern."
                    });
                    
                    if (j === pattern.length) {
                        matches.push(i - j);
                        steps.push({
                            textIndex: i - 1,
                            patternIndex: j - 1,
                            patternPosition: i - j,
                            matched: true,
                            isMatch: true,
                            found: true,
                            i: i,
                            j: j,
                            matches: [...matches],
                            comparisons: comparisons,
                            pseudoLine: 10,
                            explanation: `Pattern found at position ${i - j}! Recording this match.`
                        });
                        j = lps[j - 1];
                        
                        steps.push({
                            textIndex: i - 1,
                            patternIndex: j,
                            patternPosition: i - j,
                            i: i,
                            j: j,
                            matches: [...matches],
                            comparisons: comparisons,
                            pseudoLine: 12,
                            explanation: `Using LPS table to set pattern index to ${j} instead of starting over.`
                        });
                    }
                } else {
                    if (j !== 0) {
                        steps.push({
                            textIndex: i,
                            patternIndex: j,
                            patternPosition: i - j,
                            mismatch: true,
                            nextPatternIndex: lps[j - 1],
                            i: i,
                            j: j,
                            matches: [...matches],
                            comparisons: comparisons,
                            pseudoLine: 13,
                            explanation: `Mismatch! But we're not at the beginning of the pattern, so we can use the LPS table.`
                        });
                        j = lps[j - 1];
                        
                        steps.push({
                            textIndex: i,
                            patternIndex: j,
                            patternPosition: i - j,
                            i: i,
                            j: j,
                            matches: [...matches],
                            comparisons: comparisons,
                            pseudoLine: 14,
                            explanation: `Using LPS table to set pattern index to ${j} instead of starting over.`
                        });
                    } else {
                        steps.push({
                            textIndex: i,
                            patternIndex: j,
                            patternPosition: i - j,
                            mismatch: true,
                            nextPatternIndex: 0,
                            i: i,
                            j: j,
                            matches: [...matches],
                            comparisons: comparisons,
                            pseudoLine: 16,
                            explanation: `Mismatch at the beginning of the pattern. Moving to the next character in the text.`
                        });
                        i++;
                    }
                }
            }
            
            return steps;
        }

        // Boyer-Moore Algorithm Implementation
        function computeBadCharacterTable() {
            const badChar = {};
            
            for (let i = 0; i < pattern.length; i++) {
                badChar[pattern[i]] = i;
            }
            
            return badChar;
        }

        function displayBadCharacterTable(badChar) {
            const chars = Object.keys(badChar).sort();
            
            let tableHTML = `
                <table class="algo-table">
                    <thead>
                        <tr>
                            <th>Character</th>
            `;
            
            for (const char of chars) {
                tableHTML += `<th>${char}</th>`;
            }
            
            tableHTML += `
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Last Position</strong></td>
            `;
            
            for (const char of chars) {
                tableHTML += `<td>${badChar[char]}</td>`;
            }
            
            tableHTML += `
                        </tr>
                    </tbody>
                </table>
            `;
            
            tableWrapper.innerHTML = tableHTML;
        }

        function boyerMooreSearch() {
            const badChar = computeBadCharacterTable();
            displayBadCharacterTable(badChar);
            
            let n = text.length;
            let m = pattern.length;
            let shift = 0;
            matches = [];
            comparisons = 0;
            
            naiveComparisons = text.length * pattern.length;
            
            const steps = [];
            
            steps.push({
                textIndex: -1,
                patternIndex: -1,
                patternPosition: 0,
                shift: shift,
                matches: [...matches],
                comparisons: comparisons,
                pseudoLine: 0,
                explanation: "Starting the Boyer-Moore algorithm, which compares from right to left!"
            });
            
            while (shift <= n - m) {
                let j = m - 1;
                
                steps.push({
                    textIndex: shift + j,
                    patternIndex: j,
                    patternPosition: shift,
                    shift: shift,
                    matches: [...matches],
                    comparisons: comparisons,
                    pseudoLine: 6,
                    explanation: `Positioning pattern at text index ${shift} and starting comparison from the end of the pattern (index ${j}).`
                });
                
                while (j >= 0 && pattern[j] === text[shift + j]) {
                    comparisons++;
                    
                    steps.push({
                        textIndex: shift + j,
                        patternIndex: j,
                        patternPosition: shift,
                        isMatch: true,
                        direction: 'backward',
                        shift: shift,
                        matches: [...matches],
                        comparisons: comparisons,
                        pseudoLine: 7,
                        explanation: `Comparing text[${shift + j}]='${text[shift + j]}' with pattern[${j}]='${pattern[j]}' - they match! Moving left.`
                    });
                    j--;
                }
                
                if (j < 0) {
                    matches.push(shift);
                    steps.push({
                        textIndex: shift,
                        patternIndex: 0,
                        patternPosition: shift,
                        found: true,
                        shift: shift,
                        matches: [...matches],
                        comparisons: comparisons,
                        pseudoLine: 9,
                        explanation: `All characters matched! Pattern found at position ${shift}.`
                    });
                    
                    const nextShift = (shift + m < n) ? shift + m - (badChar[text[shift + m]] !== undefined ? badChar[text[shift + m]] + 1 : 1) : shift + 1;
                    
                    steps.push({
                        textIndex: shift,
                        patternIndex: -1,
                        patternPosition: shift,
                        shift: shift,
                        nextShift: nextShift,
                        matches: [...matches],
                        comparisons: comparisons,
                        pseudoLine: 11,
                        explanation: `Using bad character rule to shift pattern from position ${shift} to ${nextShift}.`
                    });
                    
                    shift = nextShift;
                } else {
                    comparisons++;
                    
                    const badCharShift = badChar[text[shift + j]] !== undefined ? j - badChar[text[shift + j]] : j + 1;
                    const nextShift = shift + Math.max(1, badCharShift);
                    
                    steps.push({
                        textIndex: shift + j,
                        patternIndex: j,
                        patternPosition: shift,
                        mismatch: true,
                        badCharShift: badCharShift,
                        shift: shift,
                        nextShift: nextShift,
                        matches: [...matches],
                        comparisons: comparisons,
                        pseudoLine: 14,
                        explanation: `Mismatch at text[${shift + j}]='${text[shift + j]}' and pattern[${j}]='${pattern[j]}'. Using bad character rule to shift by ${badCharShift} positions.`
                    });
                    
                    shift = nextShift;
                }
            }
            
            return steps;
        }

        // Visualization Functions
        function initializeVisualization() {
            text = textInput.value;
            pattern = patternInput.value;
            
            if (!text || !pattern) {
                showStatus('Please enter both text and pattern', 'error');
                return false;
            }
            
            if (pattern.length > text.length) {
                showStatus('Pattern cannot be longer than text', 'error');
                return false;
            }
            
            // Clear displays
            textRow.innerHTML = '';
            patternRow.innerHTML = '';
            statusBar.innerHTML = '';
            matches = [];
            comparisons = 0;
            naiveComparisons = 0;
            executionSteps = [];
            
            // Initialize pseudocode
            initializePseudocode();
            
            // Create text display
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < text.length; i++) {
                const charCell = document.createElement('div');
                charCell.className = 'char-cell';
                charCell.textContent = text[i];
                charCell.id = `text-${i}`;
                
                const indexSpan = document.createElement('span');
                indexSpan.className = 'char-index';
                indexSpan.textContent = i;
                charCell.appendChild(indexSpan);
                
                fragment.appendChild(charCell);
            }
            textRow.appendChild(fragment);
            
            // Create pattern display
            const patternFragment = document.createDocumentFragment();
            for (let i = 0; i < pattern.length; i++) {
                const charCell = document.createElement('div');
                charCell.className = 'char-cell';
                charCell.textContent = pattern[i];
                charCell.id = `pattern-${i}`;
                
                const indexSpan = document.createElement('span');
                indexSpan.className = 'char-index';
                indexSpan.textContent = i;
                charCell.appendChild(indexSpan);
                
                patternFragment.appendChild(charCell);
            }
            patternRow.appendChild(patternFragment);
            
            // Hide step explanation initially
            stepExplanation.style.display = 'none';
            
            // Initialize execution history
            executionList.innerHTML = `
                <div class="execution-step">
                    <div class="step-number">0</div>
                    <div class="step-details">
                        <div class="step-action">Ready to Start</div>
                        <div class="step-description">Click "Start" to begin the algorithm visualization</div>
                    </div>
                </div>
            `;
            
            return true;
        }

        function visualizeStep(step, stepNumber) {
            // Clear previous highlights
            document.querySelectorAll('.char-cell').forEach(cell => {
                cell.classList.remove('comparing', 'match', 'mismatch');
            });
            
            // Highlight current text character
            if (step.textIndex !== undefined && step.textIndex >= 0 && step.textIndex < text.length) {
                const textCell = document.getElementById(`text-${step.textIndex}`);
                if (textCell) textCell.classList.add('comparing');
            }
            
            // Highlight current pattern character
            if (step.patternIndex !== undefined && step.patternIndex >= 0 && step.patternIndex < pattern.length) {
                const patternCell = document.getElementById(`pattern-${step.patternIndex}`);
                if (patternCell) patternCell.classList.add('comparing');
            }
            
            // Update window position
            const patternPosition = step.patternPosition !== undefined ? step.patternPosition : (step.shift !== undefined ? step.shift : 0);
            const windowWidth = pattern.length * 36; // Adjusted for smaller cells
            windowOverlay.style.width = `${windowWidth}px`;
            windowOverlay.style.left = `${patternPosition * 36}px`;
            
            // Move pattern with window - NEW CHANGE
            patternRow.style.transform = `translateX(${patternPosition * 36}px)`;
            
            // Handle match/mismatch
            if (step.isMatch) {
                if (step.textIndex !== undefined && step.textIndex >= 0 && step.textIndex < text.length) {
                    const textCell = document.getElementById(`text-${step.textIndex}`);
                    if (textCell) {
                        textCell.classList.remove('comparing');
                        textCell.classList.add('match');
                    }
                }
                if (step.patternIndex !== undefined && step.patternIndex >= 0 && step.patternIndex < pattern.length) {
                    const patternCell = document.getElementById(`pattern-${step.patternIndex}`);
                    if (patternCell) {
                        patternCell.classList.remove('comparing');
                        patternCell.classList.add('match');
                    }
                }
            }
            
            if (step.mismatch) {
                if (step.textIndex !== undefined && step.textIndex >= 0 && step.textIndex < text.length) {
                    const textCell = document.getElementById(`text-${step.textIndex}`);
                    if (textCell) {
                        textCell.classList.remove('comparing');
                        textCell.classList.add('mismatch');
                    }
                }
                if (step.patternIndex !== undefined && step.patternIndex >= 0 && step.patternIndex < pattern.length) {
                    const patternCell = document.getElementById(`pattern-${step.patternIndex}`);
                    if (patternCell) {
                        patternCell.classList.remove('comparing');
                        patternCell.classList.add('mismatch');
                    }
                }
            }
            
            // Update pseudocode highlighting
            if (step.pseudoLine !== undefined) {
                updatePseudocodeHighlight(step.pseudoLine);
            }
            
            // Add to execution history
            let action = '';
            let description = step.explanation || '';
            let variables = [];
            let type = 'normal';
            
            if (step.found) {
                action = 'Pattern Found!';
                type = 'found';
                variables = [`i=${step.i}`, `j=${step.j}`, `matches=[${step.matches.join(', ')}]`];
            } else if (step.isMatch) {
                action = 'Characters Match';
                type = 'match';
                variables = [`i=${step.i}`, `j=${step.j}`];
            } else if (step.mismatch) {
                action = 'Characters Mismatch';
                type = 'mismatch';
                if (currentAlgorithm === 'kmp') {
                    variables = [`i=${step.i}`, `j=${step.j}`, `next_j=${step.nextPatternIndex}`];
                } else {
                    variables = [`shift=${step.shift}`, `j=${step.j}`, `shift_by=${step.badCharShift}`];
                }
            } else {
                action = 'Initializing';
                variables = [`i=${step.i}`, `j=${step.j}`];
            }
            
            addExecutionStep(stepNumber, action, description, variables, type);
            
            // Update story content if in story mode
            if (algorithmStory.style.display !== 'none' && step.explanation) {
                const storyParagraph = document.createElement('p');
                storyParagraph.className = 'story-paragraph';
                storyParagraph.innerHTML = step.explanation;
                storyContent.appendChild(storyParagraph);
                storyContent.scrollTop = storyContent.scrollHeight;
            }
            
            // Show status message
            if (step.found) {
                showStatus(`‚úÖ Pattern found at position ${step.patternPosition}`, 'success');
            } else if (step.mismatch) {
                if (currentAlgorithm === 'kmp') {
                    showStatus(`‚ùå Mismatch! Pattern index will be set to ${step.nextPatternIndex}`, 'error');
                } else {
                    showStatus(`‚ùå Mismatch! Pattern will shift by ${step.badCharShift} positions`, 'error');
                }
            } else if (step.isMatch) {
                showStatus(`‚úì Characters match!`, 'info');
            }
        }

        function showStatus(message, type) {
            const iconMap = {
                success: '‚úÖ',
                error: '‚ùå',
                info: '‚ÑπÔ∏è'
            };
            
            statusBar.className = `status-bar ${type}`;
            statusBar.innerHTML = `
                <span class="status-icon">${iconMap[type]}</span>
                <span class="status-text">${message}</span>
            `;
        }

        function startVisualization() {
            if (!initializeVisualization()) {
                return;
            }
            
            isRunning = true;
            isPaused = false;
            startBtn.disabled = true;
            haltBtn.disabled = false;
            
            // Reset story content if in story mode
            if (algorithmStory.style.display !== 'none') {
                updateStoryContent();
            }
            
            let steps;
            if (currentAlgorithm === 'kmp') {
                steps = KMPSearch();
            } else {
                steps = boyerMooreSearch();
            }
            
            currentStep = 0;
            
            function runNextStep() {
                if (!isRunning || isPaused || currentStep >= steps.length) {
                    if (currentStep >= steps.length) {
                        isRunning = false;
                        startBtn.disabled = false;
                        haltBtn.disabled = true;
                        
                        if (matches.length > 0) {
                            showStatus(`üéâ Pattern found at positions: ${matches.join(', ')}`, 'success');
                            addExecutionStep(steps.length, 'Complete', `Algorithm finished! Found ${matches.length} match(es) at positions: ${matches.join(', ')}`, [`total_comparisons=${comparisons}`], 'found');
                        } else {
                            showStatus('üòî Pattern not found in the text', 'error');
                            addExecutionStep(steps.length, 'Complete', `Algorithm finished! No matches found. Total comparisons: ${comparisons}`, [`total_comparisons=${comparisons}`], 'mismatch');
                        }
                    }
                    return;
                }
                
                visualizeStep(steps[currentStep], currentStep + 1);
                currentStep++;
                
                animationTimeout = setTimeout(runNextStep, animationSpeed);
            }
            
            runNextStep();
        }

        function haltVisualization() {
            if (!isRunning) return;
            
            isPaused = !isPaused;
            
            if (isPaused) {
                clearTimeout(animationTimeout);
                haltBtn.innerHTML = '<span>‚ñ∂</span><span>Resume</span>';
                showStatus('‚è∏ Visualization paused', 'info');
            } else {
                haltBtn.innerHTML = '<span>‚è∏</span><span>Halt</span>';
                
                // Continue from where we left off
                let steps;
                if (currentAlgorithm === 'kmp') {
                    steps = KMPSearch();
                } else {
                    steps = boyerMooreSearch();
                }
                
                function runNextStep() {
                    if (!isRunning || isPaused || currentStep >= steps.length) {
                        if (currentStep >= steps.length) {
                            isRunning = false;
                            startBtn.disabled = false;
                            haltBtn.disabled = true;
                            
                            if (matches.length > 0) {
                                showStatus(`üéâ Pattern found at positions: ${matches.join(', ')}`, 'success');
                                addExecutionStep(steps.length, 'Complete', `Algorithm finished! Found ${matches.length} match(es) at positions: ${matches.join(', ')}`, [`total_comparisons=${comparisons}`], 'found');
                            } else {
                                showStatus('üòî Pattern not found in the text', 'error');
                                addExecutionStep(steps.length, 'Complete', `Algorithm finished! No matches found. Total comparisons: ${comparisons}`, [`total_comparisons=${comparisons}`], 'mismatch');
                            }
                        }
                        return;
                    }
                    
                    visualizeStep(steps[currentStep], currentStep + 1);
                    currentStep++;
                    
                    animationTimeout = setTimeout(runNextStep, animationSpeed);
                }
                
                runNextStep();
                showStatus('‚ñ∂ Visualization resumed', 'info');
            }
        }

        function resetVisualization() {
            isRunning = false;
            isPaused = false;
            currentStep = 0;
            matches = [];
            comparisons = 0;
            naiveComparisons = 0;
            executionSteps = [];
            
            clearTimeout(animationTimeout);
            
            startBtn.disabled = false;
            haltBtn.disabled = true;
            haltBtn.innerHTML = '<span>‚è∏</span><span>Halt</span>';
            
            textRow.innerHTML = '';
            patternRow.innerHTML = '';
            tableWrapper.innerHTML = '';
            statusBar.innerHTML = '';
            pseudocodeLive.innerHTML = '';
            stepExplanation.style.display = 'none';
            
            // Reset pattern position
            patternRow.style.transform = 'translateX(0px)';
            windowOverlay.style.width = '0px';
            windowOverlay.style.left = '0px';
            
            // Reset execution history
            executionList.innerHTML = `
                <div class="execution-step">
                    <div class="step-number">0</div>
                    <div class="step-details">
                        <div class="step-action">Ready to Start</div>
                        <div class="step-description">Click "Start" to begin the algorithm visualization</div>
                    </div>
                </div>
            `;
            
            // Reset story content
            updateStoryContent();
        }

        // Event Listeners
        startBtn.addEventListener('click', startVisualization);
        haltBtn.addEventListener('click', haltVisualization);
        resetBtn.addEventListener('click', resetVisualization);

        // Update animation speed
        speedSlider.addEventListener('input', () => {
            animationSpeed = parseInt(speedSlider.value);
        });

        // Initialize with default values
        initializeVisualization();
    </script>
</body>
</html>